I worked on join() and Communicator. For join, I had a hint from the TA that each thread needed its own semaphore, so I initialized it in my constructor. Inside of the join method, I needed a check to see if the child thread is finished running and while it's not, the parent's thread must be asleep. If the child's thread is finished, then the method returns and the parent thread can continue running.
For communicator, TA suggested using two semaphores. I used one semaphore to schedule speaker and another for listener. Speak require a lock at the beginning to ensure that the listen method does not interfere and vice versa. I also have another integer to keep track of whether listen or speak is running. For the speak method, I had a loop to iterate through each thread and find a listener for the spoken thread before speak runs again. I then stored the transferred integer value, woke up all listening threads, and released the lock. I took a similar approach with the listen method.
I tested all these files with the TAs piazza test cases and added a few more threads.
For join, I created two threads. I forked both threads and joined them and printed a string to know I had finished running. The correct output would be printing the contents of each thread before printing the finished string.
For communicator, I ran the piazza test cases. I called speak before listen. All of speak’s time should occur before listen’s time and the correct value should had been properly transferred from speak to listen.
